---
title: "Spatial Associations in Culvert Cost Data"
author: "R. Fonner, B. Van Deynze"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
   html_document:
      number_sections: true
      toc: true
      toc_float:
         collapsed: true
---


```{r echo=F}
# Introduction ----
```

Because of the spatial nature of the culvert worksite data, we suspect there
may be different forms of spatial associations within the data. These
associations may undermine the assumptions of our base OLS models. We use
three tools to measure spatial heterogeneity and dependence in the cost data.  
  
1. Variograms: these plots display how the "semivariance" (half the variance
of the differences between all points within a given distance, a measure of
variance within a buffer) changes as a function of distance between
observations.  
2. Moran's I: this is a test of spatial autocorrelation, where a rejection of
the null hypothesis indicates a violation of the OLS assumption of
independent observations.
3. Anselin's Lagrange Multiplier Tests: these tests serve as an assessment of
model misspecification due to spatial associations.  

We use these tools on the base model found in [this
report](https://vandeynze.github.io/salmon_culverts/spatial_cost_models.html),
with one key change. After initial testing, we found including spatial fixed
effects like `basin` along side band-based spatial weighting schemes (i.e.
those that enforce a strict maximum distance beyond which weights are zero)
can result in a singular (or at least computationally singular) model matrix.
**Therefore, the `basin` fixed effect is removed in the models presented and
examined below.**  

```{r include=F}
#
# Investigate spatial associations
# in the culvert average cost data
# Robby Fonner
#

# Prepare environment and data ----
rm(list = ls())

library(tidyverse)
library(janitor)
library(here)
library(scales)
library(knitr)
library(kableExtra)
library(broom)
library(margins)
library(ggeffects)
library(forcats)
library(readxl)
library(geoR)
library(spdep)
library(fields)
library(sphet)


# Load NLCD key
key_nlcd <-
  read_xlsx(
    here(
      "Data/Culverts spatial overlays v 06Aug2020.xlsx"
    ), 
    sheet = 3
  ) %>% 
  as_tibble() %>%
  clean_names() %>%
  rename(
    nlcd_current_class = class,
    nlcd_current_fullclass = classification
  ) %>%
  mutate(across(where(is_character), str_to_sentence)) %>%
  filter(across(description, ~!str_detect(., "Alaska only"))) %>%
  select(-description)

# Load data
df_culv <-
  read_csv(here("output/culverts_pure_modelling.csv")) %>%
  mutate(
    # project_year = ordered(project_year),
    project_source = relevel(factor(project_source), ref = "OWRI"),
    basin = relevel(factor(basin), ref = "SOUTHERN OREGON COASTAL"),
    fips = factor(fips),
    state_fips = factor(state_fips),
    latlong = str_sub(geometry, 3, nchar(geometry)-1),
    long = as.numeric( word(latlong, 1, sep = ", ")),
    lat = as.numeric( word(latlong, 2, sep = ", "))
    # here_class = ordered(here_class)
  ) %>%
  left_join(
    key_nlcd, 
    by = c("nlcd_current" = "value")
  ) %>%
  select(-latlong) %>%
  #complete cases
  drop_na(cost_per_culvert,n_culverts,dist_mean,n_worksites,action_fishpass_culvrem_prj,action_fishpass_culvinst_prj,slope,
                        bankfull_width,here_paved,here_class,slope_deg,nlcd_current_class,hdens_cat,emp_const, emp_agforest, basin, project_year,
                        project_source)

# Estimate original model ----
  
dep <- "log(cost_per_culvert)"
indep <-
  c(
    "n_culverts" , "log(dist_mean+1)" , "factor(I(n_worksites==1))" , "action_fishpass_culvrem_prj" , "action_fishpass_culvinst_prj" ,
    # Stream features at work site: slope, bankfull width
    "slope * bankfull_width" , 
    # Road features at work site: paved, road class
    "here_paved" , "factor(here_class)" ,
    # Physical features of work site: ground slope, land cover
    "slope_deg" , "factor(nlcd_current_class)" ,
    # Population features: housing density, jobs in construction, jobs in ag/forestry
    "hdens_cat" , "emp_const" , "emp_agforest",
    # Fixed effects
    # "basin",
    "factor(project_year)" ,
    "project_source"
  )
f <- as.formula(
  paste(dep,
        paste(indep, collapse = "+"),
        sep = "~"))

mod_full <- 
  lm(f, df_culv)

summary(mod_full)
#plot(mod_full)


# Variograms ----
```

# Variograms  
  
A variogram is used to identify the distance at which the variance within a
buffer is roughly equivalent to the variance over the entire space. This
distance will then be used to define which points are considered "neighbors"
and which are not.

We construct variograms for both the dependent variable (`log(cost per
culvert)`) and the model residuals to investigate spatial dependence in both
costs and the model's errors.

```{r include=F}
##INVESTIGATE SPATIAL DEPENDENCE IN DEPENENT VARIABLE AND ERROR

##Semivariogram plots of spatial dependence against distance from observation (note: .1 degree ~ 11.1 KM)
distmat <- dist(df_culv[c("long","lat")])
#summarize distances and use information to define semivariance range (alternative buffers)
# summary(distmat)
buffs <- seq(0, .5, l = 10)
#Plot semivariance in log(avg_cost)
semivar_dep <- variog( coords = df_culv[c("long","lat")], data = log(df_culv$cost_per_culvert), breaks = buffs )
#Plot residual semivariance
semivar_res <- variog( coords = df_culv[c("long","lat")], data = mod_full$residuals, breaks = buffs )
```
```{r fig.width=10, fig.height=10, echo=F, message=F, warning=F}
plot(semivar_dep, type = "b", main = "Variogram for log(cost_per_culvert)", xlab = "distance (degree)")
plot(semivar_res, type = "b", main = "Variogram for residuals", xlab = "distance (degree)")

      # ---> Plots imply that most of the semivariance in depvar and error is captured within 
      #      20km buffer of observation
```

These plots imply that most of the semivariance in both the dependent
variable and the error term is captured within a 0.2 degree (or ~20km). We
will use this as our threshold for defining which points are neighbors. We
also remove 30 worksites with no neighbors (i.e. with no other worksites within
20km) to ensure suitable spatial weighting matrix structure.

```{r include=F}
# Prepare data for weights ----
# Remove double points
# df_culv <- df_culv %>% add_count(lat, long) %>% filter(n == 1) %>% select(-n)

# Set neighbor threshold (km)
thresh <- 20

# Identify observations with no neighbors --- problematic with 0/1 neighbor matrices, only dropping to investigate spat dep
id_mat <- nb2mat(dnearneigh(as.matrix(df_culv[c("long","lat")]), 
                          d1 = 0, d2 = thresh, longlat = T), zero.policy = T)

id_islands <- df_culv$worksite_id[colSums(id_mat) == 0]
df_culv_sp <- df_culv %>%
 filter(!worksite_id %in% id_islands)



##Estimate same model with "islands" and doubles removed
mod_full_sp <- 
  lm(f, data = df_culv_sp)
# summary(mod_full_sp)

# Generate weights ----
##CREATE NEIGHBOR AND DISTANCE MATRICIES --- after re-running model with "trimmed" sample
#Neighbor matrices -- neighbors specified based on a distance buffer assumed to have equal dependence (0/1)
w_band <- nb2listw(dnearneigh(as.matrix(df_culv_sp[c("long","lat")]),
                             d1=0, d2 = thresh, longlat = T) , style="W")
#Distance matrix in KM
coords_xy <- df_culv_sp[c("long", "lat")]
coordinates(coords_xy) <- ~long+lat
dist_km <- rdist.earth(coordinates(coords_xy), miles = F)

#Inverse distance weight matrix -- assumes dependence decays with increasing distance
w_decay <- ifelse(dist_km != 0, 1/dist_km, dist_km) #Inverse distance matrix
diag(w_decay) <- 0
w_hybrid <- ifelse(dist_km > thresh, 0, w_decay)   #Create neighbors buffer (optional)
w_decay <- mat2listw(as.matrix(w_decay), style="W")    #Normalized list
w_hybrid <- mat2listw(as.matrix(w_hybrid), style="W")

# Spatial dependence tests ----
```
```{r }
```

# Statistical tests of spatial dependence

We use the 20km range established using the above variograms to construct
three spatial weighting matrices:  
  
1. *Distance band specification*: weighting matrix is zeros and ones, where *w~ij~* =
*w~ji~* = 1 when *worksite_i* is within 20km of *worksite_j* (assumes all neighbors
within buffer have equal dependence).  
2. *Inverse distance decay specification:* weighting matrix is *w~ij~* = *w~ji~* = 1/*d~ij~*
where *d~ij~* is the distance between *worksite~i~* and *worksite~j~* (assumes
dependence decays with distance).  
3. *Hybrid specification*: weights are inverse distances when worksite pair is
within buffer, and zero otherwise.  
For each of these specifications, we estimate the core model and perform a suite of tests of spatial dependence.  
  
1. *Moran's I tests*: these tests, performed on both the dependent variable (MoranDep)
and the residuals from the model (MoranResid), identify spatial dependence, where the
null is no spatial dependence (i.e., distribution over space as good as random).  
2. *Anselin's Lagrange multiplier tests*: these tests of linear restrictions
identify mispecification due to spatial dependence, distinguishing whether
the source is due to missing spatial lags of the dependent variable or
missing spatial error structure, or both. Per Anselin's suggestion, we
consider the robust tests only if both simple tests reject the null.  
   - *LM test against error (LMerr)*: tests against the null of no spatial error.  
   - *LM test against lag (LMlag)*: tests against the null of no spatial lag structure.  
   - *Robust LM test against error (RLMerr)*: a version of LMerr robust to the presence of spatial lag.  
   - *Robust LM test against lag (RLMlag)*: a version of LMlag robust to the presence of spatial error.  
   - *LMtest against Spatial Autoregressive Moving Average (SARMA)*: tests against the null of neither spatial error nor spatial lag.  


```{r include=F}
##TESTS OF SPATIAL DEPENDENCE

# Goal is to build a table with rows as tests and columns as spatial matrix specification

# Let's put together a function that gathers the test stats based on a model and a weighting matrix
# Built for use with map and reduce

spdep_suite <-
  function(
    model,
    listw
  ){
    if(exists("y", model)) {
      y <- model$y
    } else {
      model_y <- update(model, y = TRUE)
      y <- model_y$y
    }
    #Moran's I test on on dependent variable - H0: No spatial dependence
    moran.dep.test <- moran.test(y, listw)
      moran.dep.stat <- moran.dep.test$statistic
      moran.dep.p <- moran.dep.test$p.value
    #Moran's I test on residuals
    moran.lm.test <- lm.morantest(model, listw, alternative = "two.sided")
      moran.lm.stat <- moran.lm.test$statistic
      moran.lm.p <- moran.lm.test$p.value
    #Lagrange Multiplier test for spatially model specification -- SAR? AR? SARAR?, SARA if all rejected.
    LM_test.test <- lm.LMtests(model, listw, test = "all")
    LM_test.stat <- c()
    LM_test.p <- c()
      for(i in 1:length(LM_test.test)) {
        LM_test.stat[i] <- LM_test.test[[i]]$statistic
        LM_test.p[i] <- LM_test.test[[i]]$p.value
      }
    # names(LM_test.stat) <- names(LM_test)
    # names(LM_test.p) <- names(LM_test)
    tibble(
      test_name = c("MoranDep", "MoranResid", names(LM_test.test)),
      test_stat = c(moran.dep.stat, moran.lm.stat, LM_test.stat),
      test_p = c(moran.dep.p, moran.lm.p, LM_test.p),
    ) %>% 
      mutate(
        test_stat = format(test_stat, digits = 3),
        test_p = format.pval(test_p, digits = 3, eps = 0.001)
      ) %>%
      transmute(test_name, test_out = paste0(test_stat, " (", test_p, ")"))
  }

# A - Neighbor specification (distance band)
spdep_suite(mod_full_sp, w_band)

# B - Inverse distance specification (distance decay)
spdep_suite(mod_full_sp, w_decay)

# C - Inverse distance with buffer specification (distance decay with band cutoff)
spdep_suite(mod_full_sp, w_hybrid)

```
```{r echo=F}
# All together!
# List of weighting matrix
list_weights <- lst(w_band, w_decay, w_hybrid)
# Map our function over it and present as fancy kable
map(
  list_weights,
  ~spdep_suite(mod_full_sp, .)
) %>%
  reduce(left_join, by = "test_name") %>%
  rename_with(~names(list_weights) %>% str_remove("w_") %>% str_to_sentence(), .cols = -test_name) %>%
  rename(Test = 1) %>%
  kable(
    caption = "Test statistics against spatial dependence"
  ) %>%
  kable_styling("hover") %>%
  column_spec(1 , bold = TRUE) %>%
  add_header_above(
    c(
      " " = 1,
      "Spatial weights" = 3
    )
  ) %>%
  add_footnote("P-values in parentheses", notation = "none")
```

The Moran test results indicate a strong degree of spatial clustering (or
"hot spots") in both the raw dependent variable and the residuals, though the
test statistic shrinks considerably in the residual, suggesting the observed
explanatory variables control for a portion of this effect.  

For all three weighting schemes, the first-stage LM tests are inconclusive,
rejecting the null in all cases. For the band specification, the robust LM
tests indicate a spatial error model with no spatial lag, while the hybrid
specification tests suggest the inclusion of spatial lag terms. For the decay
specification, we reject both tests for no spatial error and no lag, but the
small test statistics suggest that this weighting scheme may be the weakest,
regardless of model form. Because we observe a stronger test statistic for
the RLMerr test, we choose a spatial error model without a lag term.

```{r include=F}
# Estimate new models ----
# ESTIMATE MODELS via GMM (Kelejian & Prucha 2010)
# Band specification (neighborhood)
mod_band <- gstslshet(f, data = df_culv_sp, listw = w_band, zero.policy = F, na.omit, inverse = T, sarar = F, initial.value = "SAR")
summary(mod_band)

# Decay (inverse distance)
mod_decay <- gstslshet(f, data = df_culv_sp, listw = w_decay, zero.policy = F, na.omit, inverse = T, sarar = F, initial.value = "SAR") 
summary(mod_decay)

# Hybrid (inverse distance w/ neighborhood cut-off)
mod_hybrid <- gstslshet(f, data = df_culv_sp, listw = w_hybrid, zero.policy = F, na.omit, inverse = T, sarar = T, initial.value = "SAR") 
summary(mod_hybrid)
```

# Spatial econometric models  

Here we present three Cliff-Ord type spatial models, one for each spatial
weighting scheme. Based on the preceeding tests, we estimate these models
with only spatial error (or spatial autocorrelation) terms for the band and
decay specifications, and with a spatial lag (or spatial autoregressive) term
for the hybrid specification. We estimate these models via a GMM estimator
that accounts for heteroskedastic errors of unknown form ([Kelejian and Prucha
2010](https://doi.org/10.1016/j.jeconom.2009.10.025)).  


```{r echo=F}
tidy.sphet <- function(x) {
  
  result <- summary(x)$CoefTable %>%
    tibble::as_tibble(rownames = "term") %>%
    dplyr::rename(estimate = Estimate,
                  std.error = `Std. Error`,
                  statistic = `t-value`,
                  p.value = `Pr(>|t|)`)
  
  result
}

mods <- lst(mod_full_sp, mod_band, mod_decay, mod_hybrid)
mods_pars <-
  map_df(mods, tidy, .id = "model") %>%
  complete(model, term) %>%
  mutate(
    stars = case_when(
      p.value < 0.01 ~ "***",
      p.value < 0.05 ~ "**",
      p.value < 0.1 ~ "*",
      TRUE ~ ""
    ),
    full.est = if_else(
      is.na(estimate),
      "&#8210;",
      paste0(
        format(signif(estimate, 3), scientific = FALSE, drop0trailing = TRUE, trim = TRUE),
        stars,
        "<br>(", format(signif(std.error, 3), scientific = FALSE, drop0trailing = TRUE, trim = TRUE), ")"
      )
    ),
    term = case_when(
      term == "(Intercept)" ~ "Intercept",
      term == "action_fishpass_culvinst_prj" ~ "Culvert installation (dummy)",
      term == "action_fishpass_culvrem_prj" ~ "Culvert removal (dummy)",
      term == "n_culverts" ~ "Number of culverts",
      term == "dist_mean" ~ "Mean distance between work sites",
      term == "log(dist_mean + 1)" ~ "Mean distance between work sites, log",
      term == "factor(I(n_worksites == 1))TRUE" ~ "Single work site (dummy)",
      term == "slope" ~ "Stream slope",
      term == "bankfull_width" ~ "Bankfull width",
      term == "here_pavedY" ~ "Road paved (dummy)",
      term == "slope_deg" ~ "Terrain slope",
      term == "hdens_cat" ~ "Housing density",
      term == "emp_const" ~ "Construction employment",
      term == "emp_agforest" ~ "Ag/forestry employment",
      term == "slope:bankfull_width" ~ "Stream slope X bankfull width",
      term == "lambda" ~ "Lambda (lag parameter)",
      term == "rho" ~ "Rho (error parameter)",
      TRUE ~ term
    ),
    term = str_replace(term, "project_source", "Project source: "),
    # term = str_replace(term, "basin", "Basin: "),
    term = str_replace(term, "factor[(]project_year[)]", "Year: "),
    term = str_replace(term, "factor[(]nlcd_current_class[)]", "Land cover: "),
    term = str_replace(term, "factor[(]here_class[)]", "Road class: ")
  ) %>%
  select(
    model, term, full.est
  ) %>%
  pivot_wider(id_cols = model, names_from = term, values_from = full.est) %>%
  select(
    model,
    Intercept,
    # Stream features
    "Stream slope",
    "Bankfull width",
    "Stream slope X bankfull width",
    # Road features
    starts_with("Road"),
    # Land features
    "Terrain slope",
    starts_with("Land cover"),
    # Pop features
    "Housing density",
    ends_with("employment"),
    # Scale/scope features
    "Number of culverts",
    starts_with("Mean distance between "),
    "Single work site (dummy)",
    starts_with("Culvert "),
    starts_with("Project source: "),
    starts_with("Year: "),
    # starts_with("Basin: "),
    "Lambda (lag parameter)",
    "Rho (error parameter)"
  )

mods_pars %>%
  # left_join(mods_stats, by = "model") %>%
  pivot_longer(-model, names_to = "Term", values_to = "Value") %>%
  pivot_wider(id_cols = Term, names_from = model, values_from = Value) %>%
  select(Term, OLS = mod_full_sp, Band = mod_band, Decay = mod_decay, Hybrid = mod_hybrid) %>%
  # kable() %>%
  kable(
    caption = "Spatial dependence models",
    escape = FALSE,
    align = 
      paste0(
        "l", 
        paste(
          rep(
            "c",
            length(mods)
          ), 
          collapse = ""
        )
      )
  ) %>%
  kable_styling("hover", fixed_thead = TRUE) %>%
  column_spec(1 , bold = TRUE) %>%
  add_header_above(
    c(
      " " = 1,
      " " = 1,
      "w/ Spatial Weights" = 3
    )
  ) %>%
  add_footnote("* p < 0.1, ** p < 0.05, *** p < 0.01", notation = "none") %>%
  scroll_box(height = "1200px")
```

 
The point estimates and standard errors for the primary coefficients and
fixed effects are roughly equivalent. Interestingly, accounting for spatial
dependence results ins much more tightly estimated land cover parameters. And
the pattern of increased costs on smaller roads (after accounting for paved
status) is more pronounced.  

All spatial dependence parameters are positive and statistically significant,
indicating positive spatial spillovers in the both the error and, in the case
of the hybrid weights matrix, nearby costs. One cause of positive spillover
in the errors may be missing explanatory variables that affect costs at a
geographic scale that encompasses other worksites within range of the
weighting scheme (e.g. the band distance). The positive lambda indicates that
more expensive worksites in one location drive up costs nearby. A possible
mechanism may be competition for scarce resources (e.g. labor, machinery, etc.).  


```{r echo=F}
# Conclusion ----
```

# Closing Thoughts  

The most obvious drawback of this entire spatial dependence examination, at
this stage, is that none of our weighting matrices nor our models account for
spatio-temporal dynamics. That is, the current spatial weighting scheme
includes all projects, both in the past and in the future. Preliminary
examination of the literature on dynamic spatial econometric models is
underway, and will likely involve regenerating the weight matrices in a way
that only include contemporaneous and/or past worksites. This adds degrees of
freedom in how these matrices are constructed, as the lag over which past
worksites are included, and the degree to which they influence the spatial
effect, must be selected or estimated.  

Additional next steps will include developing methods for comparing model fit
(GMM does not lend itself well to typical likelihood-based measures like AIC
or R-squared). Initial ideas include comparing mean squared error or sum of
absolute error using bootstraping methods. I'll also need to find or build
methods for computing marginal effects for continuous variables and
prediction. Prediction for spatial econometric models can be quite
complicated due to spillovers, so this is something we'll need to be careful
with. It might be that these models are more useful for inference and the
simpler OLS-based models can be used for prediction.  

Overall, the spatial econometric methods have little effect on inference
regarding the explanatory variables. However, their inclusion does account
for an additional source of unobserved variance in the OLS models, while the
specific GMM methodology provides robustness against heteroskedastic errors.
The spatial parameters themselves provide additional richness to the
interpretation of the model.  

